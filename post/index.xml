<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on leckyyyyyyy.info</title>
    <link>http://leckyyyyyyy.github.io/post/</link>
    <description>Recent content in Posts on leckyyyyyyy.info</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 11 Jul 2015 23:54:32 +0900</lastBuildDate>
    <atom:link href="http://leckyyyyyyy.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Git push/pull を HTTPS でアクセスすると自己署名ではエラーになる</title>
      <link>http://leckyyyyyyy.github.io/post/2015/git-pushpull-https-self-signed/</link>
      <pubDate>Sat, 11 Jul 2015 23:54:32 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/git-pushpull-https-self-signed/</guid>
      <description>&lt;p&gt;Git の push/pull を HTTPS のアクセスで行うと自己署名のサーバ証明書ではデフォルトはエラーになり、アクセスできない。&lt;br /&gt;
アクセスできるようにするためには設定を変更する必要がある。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特定のリポジトリのみ変更&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;git config --local http.sslVerify false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;デフォルトの設定を変更&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;git config --global http.sslVerify false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;意図的にセキュリティに関する設定を変更するので、実際に行うときは留意する必要があります。&lt;br /&gt;
HTTPS に利用するサーバ証明書は自己署名ではないものを利用するのが望ましいですが、やむを得ないときもあるので、そのようなときにはこの対応が必要になるかと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UiAutomation#executeShellCommand は 5.0 から利用可能なメソッドだった</title>
      <link>http://leckyyyyyyy.github.io/post/2015/android-executeshellcommand/</link>
      <pubDate>Thu, 09 Jul 2015 23:25:36 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/android-executeshellcommand/</guid>
      <description>&lt;p&gt;UI Automator(コード上) で &lt;code&gt;adb shell&lt;/code&gt; を利用したいとき、ちょうど良いメソッド &lt;code&gt;UiAutomation#executeShellCommand&lt;/code&gt; を見つけたのですが、利用できるのは &lt;strong&gt;API level 21&lt;/strong&gt; からでした。&lt;br /&gt;
ビルドしようにもメソッドが存在しない旨のメッセージが表示されてエラーになって困っていましたが、落ち着いて確認するとターゲットにしているバージョンが違っていました。&lt;br /&gt;
入力補完のメソッド一覧に表示されたけど利用できなかったのですね。失敗した。&lt;/p&gt;

&lt;p&gt;調べている最中に見つけた URL 忘れるともったいないので&lt;br /&gt;
&lt;a href=&#34;https://developer.android.com/intl/ja/about/versions/android-5.0.html#TestingA11y&#34;&gt;Android 5.0 API の紹介(テストとユーザー補助)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developer.android.com/intl/ja/reference/android/app/UiAutomation.html#executeShellCommand(java.lang.String)&#34;&gt;リファレンス UiAutomation#executeShellCommand(java.lang.String)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developer.android.com/intl/ja/sdk/api_diff/21/changes.html&#34;&gt;Android API Differences Report&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;API の紹介や API の相違点のページにも今回欲しかった情報がありました。調べるときにネットでよく彷徨い続けることがあるので、気をつけないと。&lt;br /&gt;
迷わないようにまずは公式から探します。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android UI Automator の始め方</title>
      <link>http://leckyyyyyyy.github.io/post/2015/android-uiautomator-get-started/</link>
      <pubDate>Sat, 04 Jul 2015 22:30:00 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/android-uiautomator-get-started/</guid>
      <description>

&lt;p&gt;UI Automator は Android 標準の UI テストツールです。&lt;br /&gt;
UI テストは主にボタンをタップしたり、文字を入力するなどの操作をして特定のメッセージが表示される / 指定の画面が表示されるなど期待した結果になっているか確認することです。&lt;br /&gt;
ボタンをタップする、文字を入力するなどの操作部分をコードとして記述できるよう UI Automator がサポートしてくれます。&lt;/p&gt;

&lt;p&gt;テキストボックスに文字を入力してボタンを押すと次の画面を表示する、エラーメッセージを表示するなど決まった動作を確認 / テストする場合は導入しやすくコードとして記述しやすいです。&lt;br /&gt;
一度コードにしたものは「実行」するだけで同じ操作を繰り返し行ってくれるので、アプリケーションコードに変更を加えたタイミングで「実行」するなど定期的に行うことで何か間違いがあっても気付きやすくなると思います。&lt;br /&gt;
単調な操作を手動で複数回行うことはツライものがありますし、アプリケーションによっては操作するパターンが何十ともあると時間的にも精神的にもツラくなります。&lt;/p&gt;

&lt;p&gt;UI に関する操作でもスクロールが遅い / 速いやボタンをタップしたときのエフェクトなど直感的な内容に影響する部分はコードとして記述したり確認することは難しいため、手動で対応するしたほうが良い場合もあります。&lt;/p&gt;

&lt;p&gt;コードに置き換えが可能な部分は置き換えて、手動で行う必要がある部分に時間を割けるようにすることで、開発がより良くなると思います。&lt;/p&gt;

&lt;h3 id=&#34;実行環境:4a5216fdfeb236857092d744b1841597&#34;&gt;実行環境&lt;/h3&gt;

&lt;p&gt;UI Automator は 4.3 (API level 18) 以上のデバイスのみで利用できます。&lt;/p&gt;

&lt;h3 id=&#34;導入方法:4a5216fdfeb236857092d744b1841597&#34;&gt;導入方法&lt;/h3&gt;

&lt;p&gt;UI Automator を導入するには Gradle で定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
  defaultConfig {
    testInstrumentationRunner &amp;quot;android.support.test.runner.AndroidJUnitRunner&amp;quot;
  }
}

dependencies {
  androidTestCompile &#39;com.android.support.test:runner:0.3&#39;
  androidTestCompile &#39;com.android.support.test:rules:0.3&#39;
  androidTestCompile &#39;com.android.support.test.uiautomator:uiautomator-v18:2.1.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Android Studio から実行するときは &lt;strong&gt;Edit Configurations&amp;hellip;&lt;/strong&gt; から &lt;strong&gt;Android Tests&lt;/strong&gt; を選択し &lt;strong&gt;+&lt;/strong&gt; を押して追加後「Name:」に任意の名前を入力「Module:」に app を選択して作成します。&lt;br /&gt;
メニューの &lt;strong&gt;Select Run/Debug Configuration&lt;/strong&gt; で作成した Android Tests を選択し「実行」します。&lt;/p&gt;

&lt;p&gt;コンソールから実行するときは &lt;code&gt;./gradlew connectedCheck&lt;/code&gt; を実行します。&lt;br /&gt;
&lt;code&gt;[プロジェクト]/app/build/reports&lt;/code&gt; 下にレポートも作成されます。&lt;br /&gt;
&lt;small&gt;gradlew で実行できるのは UI Automator バージョン 2 からです&lt;/small&gt;&lt;/p&gt;

&lt;h3 id=&#34;サンプルコード:4a5216fdfeb236857092d744b1841597&#34;&gt;サンプルコード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.android.testing;

import android.content.Context;
import android.content.Intent;
import android.support.test.InstrumentationRegistry;
import android.support.test.filters.SdkSuppress;
import android.support.test.runner.AndroidJUnit4;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.Until;
import android.support.v7.widget.LinearLayoutCompat;
import android.test.suitebuilder.annotation.LargeTest;

import org.hamcrest.CoreMatchers;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@SdkSuppress(minSdkVersion = 18)
@LargeTest
public class UIAutomatorTest {

    private static final String APP_PACKAGE = &amp;quot;com.example.android.testing&amp;quot;;

    private static final int LAUNCH_TIMEOUT = 5000;

    private static final int UI_TIMEOUT = 5000;

    private UiDevice device;

    /**
     * アプリケーション起動に必要なIntentを作成
     *
     * @param context     {@link InstrumentationRegistry#getContext()} テスト実行のアプリケーション
     * @param packageName アプリケーションのパッケージ名
     * @return アプリケーション起動用Intent
     */
    public static Intent createLaunchIntent(Context context, String packageName) {
        final Intent intent = context.getPackageManager()
                .getLaunchIntentForPackage(packageName);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);

        return intent;
    }

    @Before
    public void setUp() {
        device = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        device.pressHome();

        Context testContext = InstrumentationRegistry.getContext();
        final Intent intent = createLaunchIntent(testContext, APP_PACKAGE);
        testContext.startActivity(intent);

        device.wait(Until.hasObject(By.pkg(APP_PACKAGE).depth(0)), LAUNCH_TIMEOUT);
    }

    @Test
    public void 前提条件() {
        Assert.assertThat(device, CoreMatchers.is(CoreMatchers.notNullValue()));
    }

    @Test
    public void Hello_worldが表示されること() {
        UiObject2 textView
                = device.wait(Until.findObject(By.text(&amp;quot;Hello world!&amp;quot;)), UI_TIMEOUT);

        Assert.assertThat(textView.getText(), CoreMatchers.is(&amp;quot;Hello world!&amp;quot;));
    }

    @Test
    public void Action_overflowを押してSettingsが表示されること() {
        UiObject2 actionOverflow
                = device.wait(Until.findObject(By.clazz(LinearLayoutCompat.class)), UI_TIMEOUT);

        actionOverflow.click();
        device.waitForIdle();

        UiObject2 menu
                = device.wait(Until.findObject(By.text(&amp;quot;Settings&amp;quot;)), UI_TIMEOUT);

        Assert.assertThat(menu.getText(), CoreMatchers.is(&amp;quot;Settings&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考 URL&lt;br /&gt;
&lt;a href=&#34;https://developer.android.com/intl/ja/tools/testing-support-library/index.html#UIAutomator&#34;&gt;https://developer.android.com/intl/ja/tools/testing-support-library/index.html#UIAutomator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://plus.google.com/+AndroidDevelopers/posts/WCWANrPkRxg&#34;&gt;https://plus.google.com/+AndroidDevelopers/posts/WCWANrPkRxg&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adobe Reader で PDF を閲覧して閉じた後も AcroRd32.exe が PC のリソースを消費している</title>
      <link>http://leckyyyyyyy.github.io/post/2015/adobe-reader-acrord32-resource-consumed/</link>
      <pubDate>Thu, 02 Jul 2015 00:31:09 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/adobe-reader-acrord32-resource-consumed/</guid>
      <description>&lt;p&gt;Adobe Reader で PDF を閲覧して閉じた後どうも CPU 使用率が下がらないので確認すると AcroRd32.exe が起動し続けていました。&lt;br /&gt;
しかも複数の PDF を同時に閲覧すると、起動した分のプロセスがタスクマネージャーに残り続けていました。残るだけなら気にしないのですが、CPU 使用率が 数10% を消費し続けていたので無視できませんでした。&lt;br /&gt;
タスクマネージャーに残り続ける理由はアップデートをチェックするためらしいです。&lt;/p&gt;

&lt;p&gt;アップデートの確認を無効にすれば解決するとの報告があるみたいですが、アップデートのチェックを無効にすると、以降は手動でアップデートのチェックを行わなければならず忘れてしまう危険があるので、今回はタスクマネージャーからプロセスを直接終了するようにしました。&lt;/p&gt;

&lt;p&gt;イメージ名 &lt;code&gt;AcroRd32.exe&lt;/code&gt;&lt;br /&gt;
コマンドライン &lt;code&gt;--type=renderer&lt;/code&gt; のコマンドが含まれる&lt;/p&gt;

&lt;p&gt;プロセスを終了することで CPU 使用率は下がったので良かったですが、PDF を利用することは多々あるので別のビューアを探すのも考えたほうが良いのかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>yum でアップデートするときに指定のパッケージを除外する</title>
      <link>http://leckyyyyyyy.github.io/post/2015/yum-package-exclude/</link>
      <pubDate>Wed, 01 Jul 2015 00:24:56 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/yum-package-exclude/</guid>
      <description>&lt;p&gt;yum でパッケージのアップデートをするときなどに指定のパッケージを除外したいことがありました。特定のバージョンを使い続ける事情があったので yum のオプションを探してみたところ &lt;code&gt;exclude&lt;/code&gt; でパッケージの除外を行えるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-x, --exclude=package
Exclude a specific package by name or glob from updates on all repositories.  Configuration Option: exclude
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンド例&lt;br /&gt;
&lt;code&gt;yum update --exclude=[パッケージ名]&lt;/code&gt;&lt;br /&gt;
[パッケージ名]に &lt;code&gt;*&lt;/code&gt; を含めることで前後/部分一致を行えるようです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>オリジナルの URL スキームを設定したアプリをコンソールから Intent を投げて起動する</title>
      <link>http://leckyyyyyyy.github.io/post/2015/android-console-send-intent/</link>
      <pubDate>Sun, 28 Jun 2015 17:02:12 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/android-console-send-intent/</guid>
      <description>&lt;p&gt;オリジナルの URL スキームを設定したアプリを起動するとき、ブラウザのリンクを開く方法がありますが、その場合 HTML を用意してブラウザからアクセスする必要があります。&lt;br /&gt;
起動を確認するのが目的の場合、コンソールから Intent を送信することでアプリの起動を確認することができます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;コンソールから Intent を送信する手順&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;コンソールを起動&lt;/li&gt;
&lt;li&gt;コンソールで &lt;code&gt;adb shell&lt;/code&gt; を実行して端末に接続&lt;/li&gt;
&lt;li&gt;コンソールで &lt;code&gt;am start -a android.intent.action.VIEW -d &amp;quot;test://example.com&amp;quot;&lt;/code&gt; を実行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;URL スキームに対応するアプリが起動するようになります。&lt;br /&gt;
&lt;code&gt;-d&lt;/code&gt; の後ろの文字列を &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; で囲っているのは URL に &amp;amp; が含まれている場合 &amp;amp; 以降の文字列が認識されないため、渡せるように囲っています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AndroidManifest.xml の設定例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    package=&amp;quot;package&amp;quot; &amp;gt;

    &amp;lt;application
        android:allowBackup=&amp;quot;true&amp;quot;
        android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;
        android:label=&amp;quot;@string/app_name&amp;quot;
        android:theme=&amp;quot;@style/AppTheme&amp;quot; &amp;gt;
        &amp;lt;activity
            android:name=&amp;quot;.MainActivity&amp;quot;
            android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;

                &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&amp;quot;android.intent.action.VIEW&amp;quot; /&amp;gt;

                &amp;lt;category android:name=&amp;quot;android.intent.category.DEFAULT&amp;quot; /&amp;gt;
                &amp;lt;category android:name=&amp;quot;android.intent.category.BROWSABLE&amp;quot; /&amp;gt;
                &amp;lt;data android:scheme=&amp;quot;test&amp;quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
        &amp;lt;/activity&amp;gt;
    &amp;lt;/application&amp;gt;

&amp;lt;/manifest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android の Espresso.onData で java.lang.IndexOutOfBoundsException が発生したときは</title>
      <link>http://leckyyyyyyy.github.io/post/2015/android-espresso-ondata-indexoutofboundsexception/</link>
      <pubDate>Wed, 24 Jun 2015 00:30:12 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/android-espresso-ondata-indexoutofboundsexception/</guid>
      <description>&lt;p&gt;Android の UI テストフレームワーク Espresso を利用しているときに Espresso.onData で &lt;code&gt;java.lang.IndexOutOfBoundsException&lt;/code&gt; が発生したときは参照している Adapter の &lt;code&gt;getCount&lt;/code&gt;、&lt;code&gt;getItem&lt;/code&gt; の実装を確認してみましょう。&lt;/p&gt;

&lt;p&gt;Espresso.onData で参照する Adapter の &lt;a href=&#34;https://code.google.com/p/android-test-kit/source/browse/espresso/lib/src/main/java/com/google/android/apps/common/testing/ui/espresso/action/AdapterViewProtocols.java#49&#34;&gt;データを取得している箇所&lt;/a&gt; で &lt;code&gt;getCount&lt;/code&gt; を呼び出しているのですが、例外が発生したコードでは getCount の返す値がデータのリストの長さを返していませんでした。&lt;br /&gt;
getItem はデータのリストを参照していたので、つじつまが合わず例外が発生していました。&lt;/p&gt;

&lt;p&gt;getCount、getItem は Adapter が保持するデータのリストを参照するはずなのですが、今回は全く異なる処理が組み込まれていたのでハマりました。&lt;br /&gt;
メソッドをオーバーライドするときは、メソッドの本来の役割を理解した上で実装しないと痛い目にあいますね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS5 で JDK6 から JDK7 へのアップデート</title>
      <link>http://leckyyyyyyy.github.io/post/2015/centos-jdk6-to-jdk7-update/</link>
      <pubDate>Tue, 23 Jun 2015 02:14:46 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/centos-jdk6-to-jdk7-update/</guid>
      <description>&lt;p&gt;CentOS5 環境の JDK6 を JDK7 にアップデートするときの手順です。&lt;/p&gt;

&lt;p&gt;今回の JDK のアップデートでは一度パッケージをアンインストールしてから目的のパッケージをインストールするため、アンインストール時に &lt;strong&gt;依存しているパッケージもアンインストール&lt;/strong&gt; されます。&lt;br /&gt;
依存しているパッケージはアンインストール時に &lt;strong&gt;Removing for dependencies&lt;/strong&gt; として表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# JDK6 をアンインストール
sudo yum remove java

# JDK7 をインストール
sudo yum install java-1.7.0-openjdk

# Java のバージョンを表示
java -version

# アンインストールしたパッケージが必要な場合は再インストール
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/log/yum.log&lt;/code&gt; でパッケージの追加/削除/更新の確認ができるので、ログから依存していたパッケージを探せます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GitLab で issue や MargeRequest の新規作成時にガイドラインを表示するには</title>
      <link>http://leckyyyyyyy.github.io/post/2015/gitlab-contributing-link/</link>
      <pubDate>Sat, 20 Jun 2015 20:14:59 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/gitlab-contributing-link/</guid>
      <description>&lt;p&gt;issue や MargeRequest を作成するとき、ルールやフォーマットなどガイドラインがあるプロジェクトではメンバーとして参加するとき説明をうけたり、別途ドキュメントとかをもらったりするかもしれませんが、作成するときには、そのガイドラインに沿っていなかったり忘れたりするときもあると思います。&lt;/p&gt;

&lt;p&gt;そのようなことを防ぐため？に GitHub や GitLab にはガイドライン用のファイルを指定のファイル名で作成することで、issue や MargeRequest を新規作成するときにリンクとして表示してくれます。&lt;/p&gt;

&lt;p&gt;GitHub でのガイドラインのリンクを表示する方法は &lt;a href=&#34;https://github.com/blog/1184-contributing-guidelines&#34;&gt;ヘルプページ&lt;/a&gt; にあります。&lt;br /&gt;
GitLab では &lt;a href=&#34;https://about.gitlab.com/2014/03/21/gitlab-6-dot-7-released/&#34;&gt;リリースノート&lt;/a&gt; に機能の説明は載っていたのですが、手順については今回調べることになったのでまとめました。&lt;/p&gt;

&lt;p&gt;リポジトリのルートディレクトリ直下にファイル名 &lt;strong&gt;CONTRIBUTING.md&lt;/strong&gt; または &lt;strong&gt;CONTRIBUTING&lt;/strong&gt; で作成。&lt;br /&gt;
&lt;small&gt;CONTRIBUTING.md と CONTRIBUTING の両方が存在したときは CONTRIBUTING が優先されるようです。&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Markdown 形式のほうがファイル単体で表示するときにも見やすいので、作成するときには CONTRIBUTING.md が良さそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jenkins で HTTP 503 が表示されたときの解決方法</title>
      <link>http://leckyyyyyyy.github.io/post/2015/jenkins-proxy-error-503/</link>
      <pubDate>Fri, 19 Jun 2015 22:09:10 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/jenkins-proxy-error-503/</guid>
      <description>&lt;p&gt;Jenkins にアクセスしたときに HTTP ステータスコード 503 が表示されたときに&lt;br /&gt;
行った解決方法です。&lt;br /&gt;
Jenkins は Apache のリバースプロキシーで運用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Jenkins のステータスを確認
sudo /sbin/service jenkins status
# Jenkins 再起動
sudo /sbin/service jenkins restart
# リバースプロキシで運用しているので、Apache 再起動
sudo /sbin/service httpd graceful
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Google でのテストに関する実行時間とテストの内容について</title>
      <link>http://leckyyyyyyy.github.io/post/2015/google-test-size/</link>
      <pubDate>Thu, 18 Jun 2015 00:22:11 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/google-test-size/</guid>
      <description>&lt;p&gt;約5年前に投稿された内容ですが、テストの内容と実行時間からテストサイズの目安を一覧にしたページを見つけました。&lt;br /&gt;
&lt;a href=&#34;http://googletesting.blogspot.jp/2010/12/test-sizes.html&#34;&gt;http://googletesting.blogspot.jp/2010/12/test-sizes.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Android に @SmallTest, @MediumTest, @LargeTest のアノテーションがあるのですが、&lt;br /&gt;
今までピンと来ずテストサイズの目安も何か参考になるのも見つけられなかったので、&lt;br /&gt;
利用していませんでした。&lt;br /&gt;
でも、この一覧があれば今後はこのアノテーションを有効活用できそうな気がします。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android のアノテーションを利用するときの基準&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@SmallTest&lt;br /&gt;
ファイルやデータベースにアクセスしないテスト&lt;/li&gt;
&lt;li&gt;@MediumTest&lt;br /&gt;
ファイルやデータベースにアクセスするテスト&lt;/li&gt;
&lt;li&gt;@LargeTest&lt;br /&gt;
UI テスト&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今後、利用するときがあったらこんな感じで使ってみたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Markdown でダイアグラム、フローチャートを作成できる JavaScriptライブラリ mermaid を使ってみた</title>
      <link>http://leckyyyyyyy.github.io/post/2015/chart-library-mermaid/</link>
      <pubDate>Tue, 09 Jun 2015 01:46:12 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/chart-library-mermaid/</guid>
      <description>

&lt;script type=&#34;text/javascript&#34; src=&#34;https://rawgit.com/knsv/mermaid/0.4.0/dist/mermaid.full.min.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://rawgit.com/knsv/mermaid/gh-pages/css/mermaid.css&#34;&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
mermaid.ganttConfig = {
  numberSectionStyles: 2
}
&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/uzuki_aoba/items/a01f8b0b52ced69c8092&#34;&gt;mermaid.jsが素晴らしいけどなかなか使ってる人見かけないので実例晒す&lt;/a&gt; を見て&lt;br /&gt;
JavaScriptライブラリをインポートして早速チャートを mermaid で作成したときの内容です。&lt;/p&gt;

&lt;h4 id=&#34;チャートを書く前に:939c930df2c84c1f866f3ac37bf04b68&#34;&gt;チャートを書く前に&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://rawgit.com/knsv/mermaid/0.4.0/dist/mermaid.full.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;https://rawgit.com/knsv/mermaid/gh-pages/css/mermaid.css&amp;quot;&amp;gt;&lt;/code&gt;&lt;br /&gt;
または上記2つのファイルをダウンロードしてリンク先に設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
mermaid.ganttConfig = {
  // 1～ の場合はガントチャートで色分けされる。0 の場合はモノクロ。
  numberSectionStyles: 2
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加&lt;/p&gt;

&lt;h4 id=&#34;チャートを書く:939c930df2c84c1f866f3ac37bf04b68&#34;&gt;チャートを書く&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;mermaid&amp;quot;&amp;gt;
// ここにチャートの定義を書くことで、この部分にチャートが描画されます。
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;チャートのデモ:939c930df2c84c1f866f3ac37bf04b68&#34;&gt;チャートのデモ&lt;/h4&gt;

&lt;p&gt;フローチャート&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;mermaid&amp;quot;&amp;gt;
graph LR
  画面1 --&amp;gt; 画面2
  画面2 --&amp;gt; 画面3
  画面1 --&amp;gt; 画面4
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph LR
  画面1 --&gt; 画面2
  画面2 --&gt; 画面3
  画面1 --&gt; 画面4
&lt;/div&gt;

&lt;p&gt;ガントチャート&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;mermaid&amp;quot;&amp;gt;
gantt
  title Webサイト作業スケジュール
  
  section 画面1
  デザイン       :a1, 2015-06-09, 10d
  プログラム開発 :a2, after a1, 10d
  テスト         :a3, after a2, 5d
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;mermaid&#34;&gt;
gantt
  title Webサイト作業スケジュール
  
  section 画面1
  デザイン       :a1, 2015-06-09, 10d
  プログラム開発 :a2, after a1, 10d
  テスト         :a3, after a2, 5d
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knsv/mermaid&#34;&gt;mermaid&lt;/a&gt; の &lt;a href=&#34;http://knsv.github.io/mermaid/usage.html&#34;&gt;セットアップ方法&lt;/a&gt; やチャート作成に必要な定義、&lt;a href=&#34;http://knsv.github.io/mermaid/demos.html&#34;&gt;デモ&lt;/a&gt; も見ながら書いてみました。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;チャートの定義が間違っていると描画する部分には何も表示されません&lt;/strong&gt; 表示されないときはブラウザのコンソールにエラーが表示されるので手助けになるかもしれないです。&lt;/p&gt;

&lt;p&gt;日本語を含めても表示されていました。&lt;br /&gt;
チャートのスタイルは CSS で変更できるので、必要に応じて変更できますね。&lt;br /&gt;
(今回、読み込んでいるのは mermaid のドキュメントを利用しています。デフォルトのスタイルが見つけられなかった。)&lt;/p&gt;

&lt;p&gt;Chrome ではフローチャート、ガントチャートどちらも表示されていますが、他のブラウザでは日本語が表示されなかったり、チャート自体が表示されないようです。&lt;br /&gt;
パスの矢印が Chrome, Firefox で表示されていないのですが、他のページで試したところ表示はされていたので、スタイルが要因かもしれません。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;フローチャート

&lt;ul&gt;
&lt;li&gt;IE11&lt;br /&gt;
日本語が表示されない&lt;/li&gt;
&lt;li&gt;Chrome, Firefox&lt;br /&gt;
パスの矢印が表示されない?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ガントチャート

&lt;ul&gt;
&lt;li&gt;Firefox&lt;br /&gt;
チャートが表示されず、定義した内容が表示される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GitHub のコンテンツをリンクで読み込めるようにする</title>
      <link>http://leckyyyyyyy.github.io/post/2015/read-github-contents/</link>
      <pubDate>Sun, 07 Jun 2015 00:53:59 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/read-github-contents/</guid>
      <description>&lt;p&gt;GitHub で公開されている JavaScript ライブラリや CSSファイルを利用したいとき&lt;br /&gt;
zip ダウンロードして必要なファイルを抜き出す。GitHub で Raw モードで開いて保存。&lt;br /&gt;
ということをしておりましたが、これだとファイルを手元に置いておく必要があるので&lt;br /&gt;
試用するときにファイルとして置くのは避けたいなと感じていました。&lt;/p&gt;

&lt;p&gt;GitHub で Raw モードで開いたときの URL を読み込み先のリンクに利用できるカナと&lt;br /&gt;
思ったのですが、Content-Type が &lt;code&gt;text/plain&lt;/code&gt; で返ってくるのでブラウザに解釈して&lt;br /&gt;
もらうには都合が悪いです。&lt;/p&gt;

&lt;p&gt;その辺りも含めてお助けしてくれるサービス &lt;a href=&#34;https://rawgit.com/&#34;&gt;RawGit&lt;/a&gt; を知りました。&lt;/p&gt;

&lt;p&gt;使い方は&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;読み込むファイルを Raw モードで開き、URL をコピー&lt;/li&gt;
&lt;li&gt;コピーした URL を &lt;a href=&#34;https://rawgit.com/&#34;&gt;RawGit&lt;/a&gt; の &lt;code&gt;Paste a GitHub file or gist URL here.&lt;/code&gt; に貼り付け&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use this URL for dev/testing&lt;/strong&gt; のテキストボックスに URL が現れるのでコピー&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;コピーした URL を読み込み先の URL として設定するだけ。&lt;/p&gt;

&lt;p&gt;開発やテストなど小さな規模での利用用途なら良さそうです。&lt;br /&gt;
&lt;a href=&#34;https://rawgit.com/faq&#34;&gt;FAQ&lt;/a&gt; に用途に関することも載っていました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CheckStyle-IDEA 4.15.0 は JDK8 が必要みたい</title>
      <link>http://leckyyyyyyy.github.io/post/2015/checkstyle-idea-4.15.0-jdk8/</link>
      <pubDate>Tue, 02 Jun 2015 22:49:58 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/checkstyle-idea-4.15.0-jdk8/</guid>
      <description>&lt;p&gt;CheckStyle-IDEA のアップデート通知があったのでプラグインのアップデートを行うと&lt;br /&gt;
&lt;code&gt;Unsupported major.minor version 52.0&lt;/code&gt; のエラーが表示されました。&lt;/p&gt;

&lt;p&gt;GitHub で公開されているので &lt;a href=&#34;https://github.com/jshiell/checkstyle-idea/blob/4.15.0/README.md#i-see-a-cannot-load-project-error-stating-unsupported-majorminor-version-520&#34;&gt;README&lt;/a&gt; を確認するとエラーメッセージの対応方法が載っていました。&lt;br /&gt;
どうやらバージョンアップの影響で JDK8 にアップデートする必要があるとのことです。&lt;/p&gt;

&lt;p&gt;このままでは IDE の起動が失敗するので、JDK8 にアップデートするか、&lt;br /&gt;
プラグインの一覧から &lt;code&gt;CheckStyle-IDEA&lt;/code&gt; を選択してプラグインの実行を無効にする必要があります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Product Flavor で利用できない名前</title>
      <link>http://leckyyyyyyy.github.io/post/2015/android-product-flavor-unavailable-name/</link>
      <pubDate>Sat, 30 May 2015 16:19:48 +0900</pubDate>
      
      <guid>http://leckyyyyyyy.github.io/post/2015/android-product-flavor-unavailable-name/</guid>
      <description>&lt;p&gt;Product Flavor の名前に BuildType で定義している名前は利用できない。&lt;br /&gt;
&lt;code&gt;ProductFlavor names cannot collide with BuildType names&lt;/code&gt; のエラーが出る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;release&lt;/code&gt; はデフォルトで定義されているので気付いたけど、&lt;br /&gt;
&lt;code&gt;debug&lt;/code&gt; を定義してみると同じエラーが出たので、予約されているようです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>